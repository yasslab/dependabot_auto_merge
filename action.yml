name: 'Dependabot Auto Merge'
description: 'Automatically approve and merge Dependabot PRs based on update type'
author: 'YassLab Inc.'

inputs:
  github-token:
    description: 'GitHub token with PR write permissions'
    required: true
  merge-level:
    description: 'Maximum semver level to auto-merge (patch, minor, or all)'
    required: false
    default: 'all'
  merge-method:
    description: 'Merge method (merge, squash, or rebase)'
    required: false
    default: 'squash'
  exclude-gems:
    description: 'Comma-separated list of Ruby gems to exclude from auto-merge'
    required: false
    default: 'rails,jekyll'
  wait-for-ci:
    description: 'true: Wait for CI to pass before merging. false: Use GitHub auto-merge'
    required: false
    default: 'true'

runs:
  using: "composite"
  steps:
    - name: Fetch Dependabot metadata
      id: metadata
      uses: dependabot/fetch-metadata@v2
      with:
        github-token: ${{ inputs.github-token }}

    - name: Check and auto-merge
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_URL:   ${{ github.event.pull_request.html_url }}
      run: |
        # Check if gem is excluded
        DEPENDENCY_NAMES="${{ steps.metadata.outputs.dependency-names }}"
        EXCLUDE_GEMS="${{ inputs.exclude-gems }}"
        
        if [ -n "$EXCLUDE_GEMS" ]; then
          IFS=',' read -ra EXCLUDED <<< "$EXCLUDE_GEMS"
          for gem in "${EXCLUDED[@]}"; do
            # Exact match check using comma boundaries
            if [[ ",$DEPENDENCY_NAMES," == *",$gem,"* ]]; then
              echo "ðŸ’Ž Gem $gem is excluded from auto-merge"
              exit 0
            fi
          done
        fi
        
        # Check if should auto-merge based on update type
        UPDATE_TYPE="${{ steps.metadata.outputs.update-type }}"
        MERGE_LEVEL="${{ inputs.merge-level }}"
        SHOULD_MERGE="false"
        
        case "$MERGE_LEVEL" in
          "patch")
            [[ "$UPDATE_TYPE" == "version-update:semver-patch" ]] && SHOULD_MERGE="true"
            ;;
          "minor")
            [[ "$UPDATE_TYPE" == "version-update:semver-patch" || \
               "$UPDATE_TYPE" == "version-update:semver-minor" ]] && SHOULD_MERGE="true"
            ;;
          "all")
            SHOULD_MERGE="true"
            ;;
        esac
        
        # Log decision
        echo "ðŸ“Š Auto-merge decision:"
        echo "  - Update type: $UPDATE_TYPE"
        echo "  - Dependency: $DEPENDENCY_NAMES"
        echo "  - Should merge: $SHOULD_MERGE"
        echo "  - Wait for CI: ${{ inputs.wait-for-ci }}"
        
        # Execute merge if conditions are met
        if [[ "$SHOULD_MERGE" == "true" ]]; then
          echo "âœ… Approving PR..."
          gh pr review --approve "$PR_URL"
          
          # Check if we should wait for CI or use auto-merge
          if [[ "${{ inputs.wait-for-ci }}" == "true" ]]; then
            echo "â³ Waiting for CI to pass before merging..."
            
            # Wait up to 60 minutes for checks to complete
            MAX_ATTEMPTS=120
            SLEEP_TIME=30
            
            for i in $(seq 1 $MAX_ATTEMPTS); do
              # Get PR status
              PR_STATUS=$(gh pr view "$PR_URL" --json statusCheckRollup,mergeable,mergeStateStatus --jq '{checks: .statusCheckRollup, mergeable: .mergeable, state: .mergeStateStatus}')
              
              # Check if all checks have passed
              CHECKS_STATUS=$(echo "$PR_STATUS" | jq -r '.checks[] | select(.status != "COMPLETED" or .conclusion != "SUCCESS") | .name' | wc -l)
              MERGEABLE=$(echo   "$PR_STATUS" | jq -r '.mergeable')
              MERGE_STATE=$(echo "$PR_STATUS" | jq -r '.state')
              
              echo "ðŸ“Š Status check: attempt $i/$MAX_ATTEMPTS"
              echo "  - Pending/failed checks: $CHECKS_STATUS"
              echo "  - Mergeable: $MERGEABLE"
              echo "  - Merge state: $MERGE_STATE"
              
              # If all checks passed and PR is mergeable
              if [[ "$CHECKS_STATUS" -eq 0 && "$MERGEABLE" == "MERGEABLE" ]]; then
                echo "âœ… All checks passed! Merging PR..."
                gh pr merge "$PR_URL" --${{ inputs.merge-method }}
                echo "ðŸŽ‰ PR successfully merged!"
                exit 0
              fi
              
              # If PR is in a failed state
              if [[ "$MERGE_STATE" == "BLOCKED" || "$MERGEABLE" == "CONFLICTING" ]]; then
                echo "âŒ PR cannot be merged due to conflicts or failed checks"
                exit 1
              fi
              
              # Wait before next attempt
              if [[ $i -lt $MAX_ATTEMPTS ]]; then
                echo "â³ Waiting ${SLEEP_TIME}s before next check..."
                sleep $SLEEP_TIME
              fi
            done
            
            echo "â±ï¸ Timeout: CI checks did not complete within 60 minutes"
            exit 1
          else
            # Use GitHub's auto-merge feature
            echo "ðŸ”„ Enabling auto-merge..."
            gh pr merge --auto --${{ inputs.merge-method }} "$PR_URL"
            echo "â„¹ï¸ Auto-merge enabled. The PR will be merged when all requirements are met."
          fi
        fi
